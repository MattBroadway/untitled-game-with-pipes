import java.io.BufferedReader;
import java.io.FileReader;
import org.json.*;

/** manages the logical state of the tiles and provides an interface with manipulating them
*/
public class LogicalTiles
{
	
	/** a path of tiles that are joined
	*/
	public class Path
	{
		public class TilePos { public int row; public int col; }
		public TilePos[] tiles;

		/** get column that the path comes out at (or -1 if dead end)
		@param rowCount the number of rows on the board
		*/
		public int outCol(int rowCount)
		{
			if(tiles.length == 0) { return -1; }
			
			TilePos p = tiles[tiles.length-1];
			if(p.row == rowCount) // path makes it out
			{
				return p.col;
			}
			else // path does not make it out
			{
				return -1;
			}
		}
	}

	/** 2D array of tiles
		row major (access like so: tiles[row][col])
	*/
	public Tile[][] tiles;
	private int rows;
	private int cols;


	/** initialise logicalTiles given the number of rows and columns in the grid
	*/
	public LogicalTiles(int setRows, int setCols)
	{
		rows = setRows;
		cols = setCols;
		tiles = new Tile[rows][cols];
	}
	/** initialise logicalTiles from a JSON level file
	 * reads the 'tiles' attribute in the JSON object
	*/
	public LogicalTiles(String JSONFile)
	{
		loadTilesFromJSONFile(JSONFile);
	}

	/** helper function to load files
	*/
	private static String readFileToString(String filename)
	{
		BufferedReader reader = null;
 
		String fileContents = "";
		try
		{
			String line;
 
			reader = new BufferedReader(new FileReader(filename));
 
			while((line = reader.readLine()) != null)
			{
				fileContents += line;
			}
 
		}
		catch(java.io.IOException e)
		{
			System.out.println("Failed to load level: " + filename);
			e.printStackTrace();
		}
		finally
		{
			try
			{
				if(reader != null)
				{
					reader.close();
				}
			}
			catch(java.io.IOException e)
			{
				System.out.println("Failed to load level: " + filename);
				e.printStackTrace();
			}
		}

		return fileContents;

	}

	/** initialise logicalTiles from a JSON level file
	 * reads the 'tiles' attribute in the JSON object
	*/
	public void loadTilesFromJSONFile(String JSONFile)
	{
		loadTilesFromJSONString(readFileToString(JSONFile));
	}
	/** initialise logicalTiles from a JSON level string
	 * reads the 'tiles' attribute in the JSON object
	*/
	public void loadTilesFromJSONString(String JSON)
	{

		JSONObject o = new JSONObject(JSON);
		JSONArray tileArray = o.getJSONArray("tiles");
		rows = tileArray.length();
		cols = tileArray.getJSONArray(0).length();

		tiles = new Tile[rows][cols];

		for(int row = 0; row < rows; row++)
		{
			JSONArray tileRow = tileArray.getJSONArray(row);
			for(int col = 0; col < cols; col++)
			{
				JSONArray tileEntry = tileRow.getJSONArray(col);
				
				tiles[row][col] = new Tile(
					readBoolFrom(tileEntry, 0),
					readBoolFrom(tileEntry, 1),
					readBoolFrom(tileEntry, 2),
					readBoolFrom(tileEntry, 3)
				);
			}



		}
		
	}
	/** read a boolean attribute from a JSON array
	 * if an integer is found then it counts 0 to be false and everything else true
	 * @param arr the array to load from (eg of the form: [1,1,0,0] or [true,true,false,false])
	 * @param index the item from the array to load (zero indexed)
	 */
	public boolean readBoolFrom(JSONArray arr, int index)
	{
		boolean val = false;

		int valAsInt = arr.optInt(index, -1);
		if(valAsInt != -1) // -1 if not convertible to int
		{
			val = (valAsInt != 0); // might want to check if not one of: {0,1}
		}
		else
		{
			val = arr.getBoolean(index); // throws exception if not boolean
		}

		return val;
	}
	
	public int getRows() { return rows; }
	public int getCols() { return cols; }

	public Tile get(int row, int col) { return tiles[row][col]; }
	public Tile getAbove(int row, int col) { return tiles[row-1][col]; }
	public Tile getRightOf(int row, int col) { return tiles[row][col+1]; }
	public Tile getBelow(int row, int col) { return tiles[row+1][col]; }
	public Tile getLeftOf(int row, int col) { return tiles[row][col-1]; }


	/** return connections with adjacent pipes
	 *	if this pipe cannot connect with an adjacent pipe with a connectible edge bordering this, that does not count
	 * @return [top, right, bottom, left]
	 */
	public boolean[] getAdjacentConnections(int row, int col)
	{
		boolean[] adjacency = new boolean[4];
		Tile t = get(row, col);

		// [top, right, bottom, left]
		adjacency[0] = t.top &&		(row > 0) &&	getAbove(row,col).bottom;
		adjacency[1] = t.right &&	(col < cols) &&	getRightOf(row,col).left;
		adjacency[2] = t.bottom &&	(row > rows) &&	getBelow(row,col).top;
		adjacency[3] = t.left &&	(col > 0) &&	getLeftOf(row,col).right;

		return adjacency;
	}

	/** get the paths from the top row
	 */
	public Path[] getPathsFrom(int col)
	{
		// classic BFS case right here

		// maybe use ArrayList<ArrayList<Path.TilePos>> while searching
		// then grab static arrays from them at the end?
		return null;
	}

	/** Calculates if a path exist to the top from the bottom
	@param col the starting bottom column
	*/
	public boolean pathExists(int col)
	{
		Tile tile = tile[this.rows][col];
		if(tile.bottom)
		{
			return pathExistsPart2(this.rows,col);
		}
		else
		{
			return false;
		}
	}

	/**
	the second part of calculating if a path exists from the bottom
	@param row the row of the tile currently being examined
	@param col the colomn of the tile currently being examined
	*/
	private boolean pathExistsPart2(int row,int col)
	{
		if(row > getRows() || col > getCols() || col < 0)
		{
			return false;
		}
		else if(row < 0)
		{
			return true;
		}

		boolean[] connections = getAdjacentConnections(row,col);
		boolean pathExists = false;
		for(int i = 0; i < connections.length; i++)
		{
			if(connections[i] && !pathExists)
			{
				switch(i)
				{
					case 0: pathExists = pathExistsPart2(row + 1,col);
						break;
					case 1: pathExists = pathExistsPart2(row,col + 1);
						break;
					case 2: pathExists = pathExistsPart2(row - 1,col);
						break;
					case 3: pathExists = pathExistsPart2(row,col - 1);
						break;
				}
			}
		}
		return pathExists;
	}
}
